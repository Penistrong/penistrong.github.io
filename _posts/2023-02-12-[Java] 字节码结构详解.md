---
layout:     post
title:      "2023-02-12-[Java] 字节码结构详解"
subtitle:   "面向JVM的.class文件结构详解"
author:     Penistrong
date:       2023-04-02 15:48:41 +0800
header-img: "img/post-bg/2023-02-12-[Java] 字节码结构详解.jpg"
categories: java jvm
catalog:    true
mathjax:    false
katex:      true
tags:
    - Java
    - JVM
---

# 字节码文件结构详解

## 什么是字节码

Java程序的一大特性便是支持跨平台，它不需要被重新编译就能够在安装了不同操作系统的计算机上运行，这个特性主要是基于JVM与字节码实现的

JVM可以理解的代码就称作**字节码**，通常是扩展名为`.class`的文件，JVM加载字节码后再进行解释执行

> 并不是只有`*.java`对应的java程序可以被`javac`编译器翻译成字节码，像Kotlin、Scala、Groovy等其他语言的源代码也可以通过各自对应的编译器编译为字节码文件，最终都可以在JVM中运行

## 字节码结构

根据JVM规范，`.class`文件通过一个结构体`ClassFile`定义:

```c++
ClassFile {
    u4             magic; // Class文件的标志
    u2             minor_version;// Class的次版本号
    u2             major_version;// Class的主版本号
    u2             constant_pool_count;// 常量池表的数量
    cp_info        constant_pool[constant_pool_count-1];// 各个常量池表
    u2             access_flags;// Class的访问标志
    u2             this_class;// 当前类的索引
    u2             super_class;// 父类的索引(Java只支持单继承，因此这里也只有一个父类)
    u2             interfaces_count;// 接口数量
    u2             interfaces[interfaces_count];// 一个类可以实现多个接口
    u2             fields_count;// Class文件的字段个数
    field_info     fields[fields_count];// 字段表数据区
    u2             methods_count;// Class文件的方法个数
    method_info    methods[methods_count];// 方法表数据区
    u2             attributes_count;// 此类的属性表中的属性数
    attribute_info attributes[attributes_count];// 属性表集合
}
```

其中`u4`、`u2`代表字段是`unsigned byte`，数字对应该字段所占的字节数，其他的诸如`cp_info`、`field_info`、`method_info`、`attribute_info`都是复合的数据结构

根据定义，即可大致知晓字节码的组成:

![字节码结构](https://s2.loli.net/2023/04/02/7nCqTyzdItwZLsH.jpg)

### 魔数 Magic Number

```c++
u4             magic; // Class 文件的标志
```

每个Class文件的首部4个字节被称为魔数 (Magic Number)，它的唯一作用是确定该字节码文件能否被虚拟机所接收，目前JVM所能识别的所有字节码文件其魔数都为固定的`0xCAFEBABE`这个32bit数

> 据说`0xCAFEBABE`是因为Java之父 James Gosling经常去一家名为`CAFEBABE`的咖啡店，所以他敲定了魔数，并沿用至今(Objective-C的Mach-o文件头部的魔数也是`0xCAFEBABE`)

### 字节码版本号

```c++
u2             minor_version;// Class 的次版本号
u2             major_version;// Class 的主版本号
```

紧随魔数之后的便是该字节码被编译时的编译器次版本号和主版本号，每当Java更新大版本，主版本号都会+1，一般来说JVM都是向下兼容的，高版本JVM可以运行低版本编译生成的字节码文件

比如，使用`javap -v *.class`查看*JDK17*编译的`.class`文件,其主版本号就是61:

```sh
javap -v SegmentTree.class

...
public class org.penistrong.template.tree.SegmentTree
  minor version: 0
  major version: 61
...
```

### 常量池 Constant Pool

```c++
u2             constant_pool_count;// 常量池的数量
cp_info        constant_pool[constant_pool_count-1];// 常量池
```

Class文件中的常量池不等同于JVM结构里的*常量池*，个人觉得可以将字节码中的常量池称为常量池表，JVM在加载类文件(即Class文件时)，会将常量池表中的字面量和符号引用等加载到JVM方法区中的运行时常量池中

字节码的常量池实际大小为`constant_pool_count - 1`，空出第0项是因为Jaba规定了索引为0代表"不引用任何一个常量池项"，每一个常量池项其本身就是一个表，记录每种常量类型对应的各个常量

一共有14种类型，每个表的第一个字节(`u1`类型标志位)标识了常量表对应的类型:

| 标志位(`u1`tag) | 类型 | 描述 |
| ------------- | --- | ---- |
|  1 | CONSTANT_utf8_info               | UTF-8编码的字符串
|  3 | CONSTANT_Integer_info            | 整型字面量
|  4 | CONSTANT_Float_info              | 单精度浮点型字面量
|  5 | CONSTANT_Long_info               | 长整型字面量
|  6 | CONSTANT_Double_info             | 双精度浮点型字面量
|  7 | CONSTANT_Class_info              | 类或接口的符号引用
|  8 | CONSTANT_String_info             | 字符串类型字面量
|  9 | CONSTANT_Fieldref_info           | 字段的符号引用
| 10 | CONSTANT_Methodref_info          | **类中方法**的符号引用
| 11 | CONSTANT_InterfaceMethodref_info | **接口中方法**的符号引用
| 12 | CONSTANT_NameAndType_info        | 字段或方法的符号引用
| 15 | CONSTANT_MethodHandle_info       | 方法句柄
| 16 | CONSTANT_MethodType_info         | 方法类型
| 18 | CONSTANT_InvokeDynamic_info      | 动态方法的调用点

第一个CONSTANT_utf8_info，应该是每个Class文件常量池中最多的常量，因为它保存了字段名称、方法名称等所有源码出现的非保留字名称，

### 访问标志 Access Flags

```c++
u2             access_flags;// Class的访问标志
```

访问标志用于标识当前Class是类还是接口，是否为`public`或者`abstract`类型，如果是类的话再判断是否为不可继承的`final`类型

| Flag Name | Value | Interpretation |
| --------- | ----- | -------------- |
| ACC_PUBLIC     | 0x0001 | 声明为`public`，可被包外类访问
| ACC_FINAL      | 0x0010 | 声明为`final`，不允许存在继承它的子类
| ACC_SUPER      | 0x0020 | 使用`invokespecial`指令执行实例方法时，特殊对待子类方法
| ACC_INTERFACE  | 0x0200 | 说明当前Class为接口而不是类
| ACC_ABSTRACT   | 0x0400 | 声明为`abstract`，不能被实例化
| ACC_SYNTHETIC  | 0x1000 | 声明为`synthetic`，不是源码中的而是编译器生成的
| ACC_ANNOTATION | 0x2000 | 声明为注解类型
| ACC_ENUM       | 0x4000 | 声明为枚举类型

注意到各个访问标记对应的十六进制值都是错开的，多个访问标志其实重叠在`u2`这个2字节16bit类型上，通过分离每一个十六进制位就可以直到当前Class的修饰符

比如，存在一个`public abstract`的抽象类，该类对应的Access Flag就是`0x0401 = 0x0400(ACC_ABSTRACT) + 0x0001(ACC_PUBLIC)`

### 当前类、父类、接口索引集合

```c++
u2             this_class;// 当前类的索引
u2             super_class;// 父类的索引(Java只支持单继承，因此这里也只有一个父类)
u2             interfaces_count;// 接口数量
u2             interfaces[interfaces_count];// 一个类可以实现多个接口
```

JVM根据字节码中的当前类索引、父类索引、接口索引表这三项确定当前Class的继承关系：

- 当前类索引指向该类的全限定名

- 父类索引指向该类的直接父类的全限定名(这里可以发现只有一个父类，说明Java是单继承的)，而所有的类的最左边界(顶级父类)一定是`java.lang.Object`，因此除了`Object`类外其他所有Java类的父类索引都不为0

- 接口索引由接口数量和接口索引表组成，Java规定了类可以实现多个接口，当前类实现的接口会按照源码中`implements`的顺序排列在接口索引表里(如果当前Class本身就是接口，则它`extends`的接口也是按出现顺序排列)

### 字段表集合 Fields

```c++
u2             fields_count;// Class文件的字段个数
field_info     fields[fields_count];// 字段表数据区
```

当前Class的字段表由字段数量和字段表数据区组成，用于描述当前Class里声明的变量，字段包括类变量(静态变量)、实例变量(实例化后才有具体的值)，但是**不包括方法内部声明的局部变量**

`field info`结构体如下所示：

```c++
field_info {
    u2              access_flags;
    u2              name_index;
    u2              descriptor_index;
    u2              attributes_count;
    attribute_info  attributes[attributes_count];
}
```

1. `access_flags`: 字段的作用域修饰符(`public`, `protected`, `private`)，实例变量or类变量(`static`修饰)，该字段能否被序列化(`transient`)，可变性(`final`)，可见性(`volatile`)

2. `name_index`: 对常量池中该字段**名称**对应的utf8字符串的引用(以常量池索引表示)

3. `descriptor_index`: 对常量池中该字段**描述符**对应的utf8字符串的引用(以常量池索引表示)

4. `attributes_count`: 某些字段还会拥有额外的属性，该变量记录额外属性的个数

5. `attributes[attributes_count]`: 存放该字段拥有的具体额外属性

字段的`access_flags`类似于类的`Access Flags`，修饰符标志几乎一样，但是相较类的修饰符增加了字段特有的标志:

| Flag Name | Value | Interpretation |
| --------- | ----- | -------------- |
| ACC_PRIVATE     | 0x0002 | 声明为`private`，只能在声明该字段的类内部使用
| ACC_PROTECTED   | 0x0004 | 声明为`protected`，可以被继承该类的子类访问
| ACC_STATIC      | 0x0008 | 声明为`static`，指示该字段是否是类变量
| ACC_VOLATILE    | 0x0040 | 声明为`volatile`，指示该字段不能被线程缓存，只能到主存中读取
| ACC_TRANSIENT   | 0x0080 | 声明为`transient`，指示该字段不能被序列化

其他标志都已复用，只是在字段上表示时的意义不同，比如`ACC_FINAL`修饰字段时指示该字段不能在实例构造后被赋值

### 方法表集合

```c++
u2             methods_count;// Class文件的方法个数
method_info    methods[methods_count];// 方法表数据区
```

Class文件中，对于方法的描述与对字段的描述一致，首先方法名和方法描述符都需要存储为常量池的`CONSTANT_utf8_info`的字符串，同时方法内部的局部变量嵌套存储在方法表结构体`method_info`

`method_info`结构体如下所示：

```c++
method_info {
    u2              access_flags;
    u2              name_index;
    u2              descriptor_index;
    u2              attributes_count;
    attribute_info  attributes[attributes_count];
}
```

其中`access_flag`的取值比其类、字段的访问标志取值多出好几项，同时因为`volatile`、`transient`修饰符不可以修饰方法，所以去掉了这两个标志：

| Flag Name | Value | Interpretation |
| --------- | ----- | -------------- |
| ACC_SYNCHRONIZED | 0x0020 | 声明为`synchronized`，调用该方法时会使用monitor包裹它，防止其他线程并发调用
| ACC_BRIDGE       | 0x0040 | 由编译器生成的桥接方法(所以`ACC_SYNTHETIC`这个标志也会一并启用)，编译器在进行泛型擦除或者处理该方法的协变返回类型时就会生成桥接方法
| ACC_VARARGS      | 0x0080 | 指示该方法拥有可变数量的参数
| ACC_NATIVE       | 0x0100 | 声明为`native`，说明该方法实际由非java实现，调用该方法要走本地方法栈
| ACC_STRICT       | 0x0800 | 声明为`strictfp`，采用精确浮点数模式

### 属性表集合

```c++
u2             attributes_count;// 此类的属性表中的属性数
attribute_info attributes[attributes_count];// 属性表集合
```

类、字段表、方法表中都会携带自己的属性表集合，其它数据项的约束相对严格，但是属性表的限制就较为宽松，编译器可以向其中写入自己定义的属性信息

类的属性表通常包含类的签名`Signature`、源文件名索引`SourceFile`、类启动方法`BootstrapMethods`、内部类`InnerClasses`

![类的属性表](https://s2.loli.net/2023/04/02/BNF36op1YTKXkJl.png)

> 所有的属性名、字段名、方法名等都是以常量池索引的形式保存的，索引到常量池中这些名称对应的UTF-8字符串
