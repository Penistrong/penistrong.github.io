---
layout:     post
title:      "实验代码 《汇编语言》王爽"
subtitle:   "Assembly Language"
author:     Penistrong
date:       2021-02-03 20:44:05 +0800
categories: jekyll update
catalog: true
tags:
    - ASM
    - 80X86
---

# 《汇编语言》王爽 实验代码

- ## 实验10
    编写3个子程序
    - 子程序①：在指定位置，用指定颜色，显示一个用0结束的字符串
    - 子程序②：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型
    - 子程序③：将data段中的数据以十进制的形式显示出来

```asm
assume cs:code
data segment
    db 'Welcome to MASM!', 0
data ends

code segment
start:  mov ax, 4240h
        mov dx, 000Fh
        mov cx, 0AH
        call far ptr divdw  ;测试子程序②-DEBUG下查看(dx)=0001H (ax)=86A0H (cx)=0

        mov ax, 12666
        mov bx, data
        mov ds, bx
        mov si, 0
        call dtoc           ;测试子程序③-将数值转换成对应的十进制字符串,用子程序①的测试是否转换成功

        mov dh, 8
        mov dl, 3
        mov cl, 2
        call show_str       ;测试子程序①-查看第8行第3列是否显示绿色字符串

        mov ax, 4c00h
        int 21h
;子程序①:显示一个用0结束的字符串 字符串首址在ds:si处
;Params: dh=行号(0~24) dl=列号(0~79) cl=颜色
;return: null
show_str:   push dx
            push cx
            push si
Initialize: mov ax, 0B800h
            mov es, ax
            mov ax, 0A0h
            mul dh              ;计算给出的第(dh)行所在的首址 (dh)*160 byte
            mov bp, ax          ;送偏移地址寄存器bp
            mov ax, 2       
            mul dl              ;计算给出的第(dl)列所在的偏移地址 (dl)*2 byte
            mov di, ax          ;送偏移地址寄存器di
            mov ah, cl          ;将颜色字符串送到ah
            mov si, 0
s1:         xor cx, cx          ;cx置零
            mov cl, ds:[si]     ;取字符串的字符(8bitASCII码)
            jcxz ret1         ;若为0则跳转至ret处
            
            mov al, cl          ;此时将cl中存储的字符ASCII码送入al
            mov es:[bp][di], ax ;将字符与其属性的组合送入显示缓冲区

            inc si              ;字符串指针+1
            add di, 2           ;显示缓冲区指针+2
            jmp short s1
ret1:       pop si
            pop cx
            pop dx
            ret

;子程序②:进行不会产生溢出的除法运算,被除数为dword,除数为word,结果为dword
;描述:   使用公式X/N=int(H/N)*65536+[rem(H/N)*65536+L]/N
;Params: (ax)=被除数低16位 (dx)=被除数高16位 (cx)=除数
;return: (ax)=结果低16位 (ax)=结果高16位 (cx)=余数
divdw:      push ax     ;被除数低16位L入栈
            push dx     ;被除数高16位H入栈
            ;开始计算H/N
calculate:  pop ax      ;高16位H出栈作32位被除数的低16位
            xor dx, dx  ;32位被除数高16位置零
            div cx      ;计算H/N ax中存放商即int(H/N)部分 dx中存放余数rem(H/N)
            pop bx      ;被除数低16位L出栈 暂存于bx中
            push ax     ;int(H/N)入栈
            ;开始计算[rem(H/N)*65536+L]/N 此时余数作为32位被除数的高16位(直接使用dx) 原被除数的低16位直接使用
            mov ax, bx
            div cx      ;计算[rem(H/N)*65536+L]/N ax中存放dword型结果的低16位
            mov cx, dx  ;余数送入cx中
            pop dx      ;int(H/N)出栈 送入dx(即结果dword型的高16位)

            ret

;子程序③:将word型数据转变为表示十进制数的字符串，字符串以0结尾
;描述: 用除法 每次除10 拿到每位上的十进制值(余数) 注意需要逆序输出 使用栈存储每个余数(每个数位)对应的ASCII码
;Params: (ax)=word型数据 ds:si指向字符串的首地址
;return: null
dtoc:       push ax         ;要处理的数 入栈
            mov bx, 10      ;除数10
            xor cx, cx      ;cx置零
            xor dx, dx      ;dx置零
s3:         div bx          ;采用16位除法(若采用8位除法,单步结果不一定小于256) ax存储商 dx存储余数
            add dx, 30H     ;余数(0~9)的实际数值+30H即得到它们对应的ASCII码
            push dx         ;入栈 准备逆序输出
            xor dx, dx      ;dx置零 防止上一步中的余数作为下一步运算的高16位而产生错误
            inc si

            mov cx, ax      ;若商为0说明各位的值已全部求出
            jcxz ret2       ;写在inc si后面让si顺便记录循环次数

            jmp short s3
ret2:       mov cx, si      ;准备逆序输出栈中存储的各余数字符
            mov si, 0       ;si复用为偏移地址寄存器
s4:         pop dx          ;由于栈只能使用16位，因此dl为实际ASCII码
            mov ds:[si], dl
            inc si
            loop s4

            pop ax          ;复原ax
            ret
code ends
end start
```

---

- ## 实验11
    编写一个子程序，将包含任意字符，以0结尾的字符串中的小写字母转换为大写字母
    - 参数: ds:si指向字符串首地址

```asm
assume cs:codesg

datasg segment
    db "Beginner's All-purpose Symbolic Instruction Code.", 0
datasg ends

codesg segment
start:  mov ax, datasg
        mov ds, ax
        mov si, 0
        call letterc

        mov dh, 8
        mov dl, 3
        mov cl, 2
        call show_str       ;调用子程序显示字符串检查是否将小写转换为大写

        mov ax, 4c00h
        int 21h

letterc:push si         ;保存
s:      mov al, [si]
        cmp al, 0
        je over         ;(al)=0,已读到字符串结束符
        cmp al, 97      
        jb continue     ;小于小写字母a对应的ASCII码97则不处理
        cmp al, 122
        ja continue     ;大于小写字母z对应的ASCII码122则不处理
        sub al, 20H     ;(al)-=32(20H) 得到小写字母其对应大写的ASCII码
        mov [si], al
continue:inc si         ;偏移地址++, 继续读取下一个字符
         jmp s
over:   pop si
        ret

;子程序①:显示一个用0结束的字符串 字符串首址在ds:si处
;Params: dh=行号(0~24) dl=列号(0~79) cl=颜色
;return: null
show_str:   ......      ;见上一实验

codesg ends

end start
```

---

- ## 实验12
    - 编写0号中断的处理程序，使得在除法溢出发生之前，在屏幕中间显示字符串“Divide error！”，然后返回到DOS

```asm
assume cs:code

code segment
start:  mov ax, cs
        mov ds, ax
        mov si, offset do0                  ;指向待安装的中断处理程序所在的源地址
        mov ax, 0
        mov es, ax
        mov di, 0200H                       ;送入中断处理程序的目标内存地址
        mov cx, offset do0end - offset do0  ;通过编译器计算中断处理程序do0所占的字节个数
        cld                                 ;设置串传送指令的传输方向为正
        rep movsb
        mov ax, 0
        mov es, ax
        mov word ptr es:[0*4], 0200H        ;设置中断向量表中0号中断的偏移地址
        mov word ptr es:[0*4+2], 0          ;设置中断向量表中0号中断的段地址

        ;测试是否已安装新的除法溢出中断处理程序
        mov ax, 1000H
        mov bh, 1
        div bh

        mov ax, 4C00H
        int 21H

do0:        jmp short do0start
            db "Divide error!"
do0start:   mov ax, cs
            mov ds, ax
            mov si, 0202H                   ;待显示的字符串的地址(在内存中存放中断处理程序的地址)

            mov ax, 0B800H
            mov es, ax
            mov di, 12*160+36*2             ;显示在第12行(从第0行开始)第36列

            mov cx, 13                      ;待显示字符串的长度
s:          mov al, [si]                    ;传送字符对应的ascii码
            mov ah, 00001100B               ;设置字符的属性
            mov es:[di], ax                 ;送入显存空间
            inc si
            add di, 2
            loop s

            mov ax, 4C00H
            int 21H
do0end:     nop
code ends
end start
```

---

- ## 实验13
- 编写并安装int 7ch号中断例程，功能为显示一个用0结束的字符串，中断例程安装在0:200处

```asm
assume cs:code

data segment
    db "Welcome to masm", 0
data ends

code segment
start:  mov ax, cs
        mov ds, ax
        mov si, offset show_str             ;指向待安装的中断处理程序所在的源地址
        mov ax, 0
        mov es, ax
        mov di, 0200H                       ;送入中断处理程序的目标内存地址 0000:0200 处
        mov cx, offset show_str_end - offset show_str   ;通过编译器计算中断处理程序do0所占的字节个数
        cld                                 ;设置串传送指令的传输方向为正
        rep movsb

        mov ax, 0
        mov es, ax
        mov word ptr es:[7ch*4], 0200H      ;设置中断向量表中7ch号中断的偏移地址
        mov word ptr es:[7ch*4+2], 0        ;设置中断向量表中7ch号中断的段地址

        ;测试中断是否成功安装
        mov dh, 10
        mov dl, 10
        mov cl, 00000010B                   ;绿色
        mov ax, data
        mov ds, ax
        mov si, 0
        int 7ch

        mov ax, 4C00H
        int 21H

;将实验10中使用的显示字符串的子程序作为中断例程安装
;子程序①:显示一个用0结束的字符串 字符串首址在ds:si处
;Params: dh=行号(0~24) dl=列号(0~79) cl=颜色
;return: null
show_str:   push dx
            push cx
            push si
Initialize: mov ax, 0B800h
            mov es, ax
            mov ax, 0A0h
            mul dh              ;计算给出的第(dh)行所在的首址 (dh)*160 byte
            mov bp, ax          ;送偏移地址寄存器bp
            mov ax, 2       
            mul dl              ;计算给出的第(dl)列所在的偏移地址 (dl)*2 byte
            mov di, ax          ;送偏移地址寄存器di
            mov ah, cl          ;将颜色字符串送到ah
            mov si, 0
s1:         xor cx, cx          ;cx置零
            mov cl, ds:[si]     ;取字符串的字符(8bitASCII码)
            jcxz ret1         ;若为0则跳转至ret处
            
            mov al, cl          ;此时将cl中存储的字符ASCII码送入al
            mov es:[bp][di], ax ;将字符与其属性的组合送入显示缓冲区

            inc si              ;字符串指针+1
            add di, 2           ;显示缓冲区指针+2
            jmp short s1
ret1:       pop si
            pop cx
            pop dx
            iret
show_str_end:   nop             ;占位 以计算中断例程部分有用的机器码字节数 便于安装

code ends
end start
```

- 编写并安装int 7ch的中断例程，功能为完成loop指令的功能

```asm
assume cs:code
code segment
start:  mov ax, cs
        mov ds, ax
        mov si, offset lp                   ;指向待安装的中断处理程序所在的源地址
        mov ax, 0
        mov es, ax
        mov di, 0200H                       ;送入中断处理程序的目标内存地址 0000:0200 处
        mov cx, offset lp_end - offset lp   ;通过编译器计算中断处理程序do0所占的字节个数
        cld                                 ;设置串传送指令的传输方向为正
        rep movsb

        mov ax, 0
        mov es, ax
        mov word ptr es:[7ch*4], 0200H      ;设置中断向量表中7ch号中断的偏移地址
        mov word ptr es:[7ch*4+2], 0        ;设置中断向量表中7ch号中断的段地址

        ;测试loop中断是否成功安装
        mov ax, 0B800H
        mov es, ax
        mov di, 160*12
        mov bx, offset s - offset se
        mov cx, 80
s:      mov byte ptr es:[di], '!'
        add di, 2
        int 7ch
se:     nop
        mov ax, 4c00h
        int 21h

lp:     push bp
        mov bp, sp
        dec cx
        jcxz lpret
        add [bp + 2], bx       ;将堆中存放的此前调用中断时入栈的IP值加上转移位移 中断返回时达到修改IP的目的
lpret:  pop bp
        iret
lp_end: nop

code ends
end start
```

- 使用系统提供的10号中断和21号中断在屏幕的第2,4,6,8行显示四句英文诗

```asm
assume cs:code
code segment
s1: db 'Good,better,best,','$'
s2: db 'Never let it rest,','$'
s3: db 'Till good is better,','$'
s4: db 'And better,best.','$'
s:  dw offset s1, offset s2, offset s3, offset s4
row:    db 2, 4, 6, 8

start:  mov ax, cs
        mov ds, ax
        mov bx, offset s
        mov si, offset row
        mov cx, 4
ok:     mov bh, 0
        mov dh, ds:[si]
        mov dl, 0
        mov ah, 2
        int 10h             ;调用10号中断的2号功能 设置光标位置 (BH)为页码 (DH)为行坐标 (DL)为列坐标

        mov dx, [bx]        ;将bx中存放的各诗句所在的偏移地址 使用ds:[bx]取到这些诗句实际的偏移地址送入dx
        mov ah, 9
        int 21h             ;调用21号中断的9号功能 显示字符串 DS:DX为串地址 以'$'结尾
        inc si
        add bx, 2           ;s中存放的是各诗句的偏移地址(word型) 故取下一个偏移地址执行bx+=2即可
        loop ok

        mov ax, 4c00h
        int 21h

code ends
end start
```