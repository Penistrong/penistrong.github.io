---
layout:     post
title:      "[Spring Cloud] 微服务架构组件特点"
subtitle:   "Nacos, Sentinel, Spring Cloud Gateway, RabbitMQ, etc."
author:     Penistrong
date:       2023-03-04 21:39:16 +0800
categories: jekyll update
catalog:    true
mathjax:    false
katex:      true
tags:
    - Java
    - Spring
    - Spring Cloud
---

# Spring Cloud 微服务架构常用组件特点

## Sentinel

大型微服务系统中高可用性的重要一环便是 **服务容错**。

高可用性保障的一种常规操作是通过搭建分布式服务集群以避免单点故障，但是在面对 **服务雪崩** 时仍不具备保障。服务集群中总会存在部分服务，其底层需要对数据库等数据源进行数据读写，假设它需要执行一段性能没有优化的SQL语句，这样的话单次DB操作的执行时间会稍长，在并发量较小的情况下通常不会存在问题，一旦并发量井喷，这种性能上的些微差距就会被迅速放大

这种情况下，该服务会迅速消耗数据库的连接资源，进而导致该服务提供接口的响应时间不断延长，而上级服务的请求又在源源不断地抵达该服务，这样接口超时就会如雪崩一般毁灭性地滚向上级服务，再淹没更上级的服务，导致整个服务集群不可用。

*Sentinel*就是一款能够应对服务雪崩的服务容错组件，它按照"内外兼修"的思路消弭服务雪崩，犹如前线的**哨兵**一样:

### 内部异常治理

Sentinel采取 **降级** 与 **熔断** 的方式处理服务集群内部出现的异常:

- 降级: 当服务调用发生响应超时、服务异常等情况时，可以转而执行**降级逻辑**，比如重试请求、恢复异常、默认返回等，降级是针对**单次**服务调用异常而执行的处理逻辑

- 熔断: 当服务异常积累到一定阈值时，比如某段时间窗口内降级请求出现了一定次数，则Sentinel会让该发起调用的微服务在一段时间内停止向目标服务发起调用，所有相关请求直接执行降级逻辑。所以熔断是**多次**服务调用异常而执行的处理逻辑

### 外部流量控制

Sentinel可以通过流量整形、流量控制等方案，为每个微服务设置规则，从QPS或并发请求线程数等维度控制外界来访流量。一旦访问量超过阈值，Sentinel可以采取多重手段处理后续到达的请求

从限流算法的角度而言，常用的限流算法有滑动窗口、令牌桶、漏桶等，Sentinel的3种流控策略也是按照限流算法的思想设计的:

- 快速失败 Fast Fail: 直接丢弃请求，抛出异常`Blocked by Sentinel(flow limiting)`
  > 快速失败$\to$*滑动窗口*: 如果一段滑动时间窗口内的QPS或者并发线程数超过一定阈值，直接丢弃多余的请求

- 预热冷启动 Warm Up: 在一段规定的预热时间窗口内，由低到高逐渐拉高流量阈值，直到预设的最高阈值位置
  > 预热冷启动$\to$*令牌桶*: 通过动态调整令牌桶容量大小，流量阈值逐渐升高，达到预热效果

- 排队等待: 将后续的服务请求放入缓冲队列，如果该请求在预设的超时时间内仍未被处理，则将其移出队列丢弃
  > 排队等待$\to$*漏桶*: 所有的请求数据包放入漏桶进行排队等待，漏桶以一定的速率放行数据包，达到匀速效果

## Spring Cloud Gateway

Gateway本身就是一个微服务，它也是Nacos服务注册中心的一员。而Gateway能连接到Nacos，那它就可以接收Nacos推送的其他所有微服务的注册表(比如ip:port)，这样Gateway就可以根据本地路由规则，将请求准确无误地送达到每个微服务组件中

使用Gateway的好处就在于它的高扩展性，对微服务集群做扩容或者缩容，Gateway都能从服务注册中心获取所有服务节点的变动

### Gateway路由规则

Spring Cloud Gateway的路由规则由三部分组成:

1. **路由**: 基本单元，每个RouteLocator都有一个目标服务地址，指向当前路由规则要调用的目标服务

2. **谓词**: 路由的判断规则，满足谓词规则就会将请求进行发送，Gateway有很多内置谓词可以构造复杂路由条件

3. **过滤器**: Gateway转发请求到目标服务时，由filter处理，它采用一种过滤链(filter chain)的方式，在发送request和接收response时都会走一遍过滤器，大致分为两种过滤器: GlobalFilter(全局)和GatewayFilter(局部，针对指定路由生效)

#### 路由声明

三种方式:Java代码、yaml文件、动态路由，前两种都是硬编码，在代码或者配置文件中写死路由声明，项目启动后只会加载一次，运行期修改路由只能依靠动态路由加载

比如，Gateway可以监听Nacos Config中的文件变动，动态获取Nacos配置中心里配置的规则

#### 内置谓词

常用谓词也分3种:

1. 寻址谓词: 针对请求地址和类型做判断，比如`uri`、`path`和`method`(`RouterLocator类的成员变量`)
2. 请求参数谓词: 包括Query参数`query`、`cookie`、`header`
3. 时间谓词: 借助`before`、`after`、`between`控制当前路由的生效时间段

#### 过滤器

用一段例子演示过滤器的基础使用，下面是使用Java代码定义路由规则

```java

@Configuration
public class RoutesConfiguration {

    @Bean
    public RouteLocator declare(RouteLocatorBuilder builder) {
        return builder.routes()
                .route(route -> route
                        .path("/gateway/coupon-customer/**")
                        .filters(f -> f.stripPrefix(1))
                        .uri("lb://coupon-customer-service")
                ).route(route -> route
                        .order(1)
                        .path("/gateway/template/**")
                        .filters(f -> f.stripPrefix(1))
                        .uri("lb://coupon-template-service")
                ).route(route -> route
                        .path("/gateway/calculator/**")
                        .filters(f -> f.stripPrefix(1))
                        .uri("lb://coupon-calculation-service")
            ).build();
    }
}
```

`path`谓词约定了路由匹配规则为`/gateway/template/**`，注意上面的多个route间可以通过设置`.order()`设定路由优先级，越小越优先

`filters`过滤器里指定了一个`stripPrefix`过滤器，给定参数`1`的情况下过滤器在路由匹配后给目标微服务发送请求的时候将请求URL的前置子路径删除`1`个，变成了`/template/**`，符合微服务里定义好的Controller接口

`uri`指定了当前路由的目标转发地址，前面的`lb`即`loadBalance`，将使用本地负载均衡将请求转发到名为`coupon-template-service`的微服务

### 从Nacos Config获取动态路由表

## 消息队列 RabbitMQ

> 消息驱动是通过"削峰填谷"解决高并发场景

消息驱动场景有很多种，下面有4种经典场景

### 服务间解耦

如果没有消息队列，那么微服务之间仍然存在上下游间的直接调用关系，类似于耦合的业务场景，比如某个上游微服务通过某个事件触发了多个下游业务，这类场景就需要消息驱动技术进行解耦合

消息队列可以收纳业务场景里某个微服务下的业务发送出的消息，与其关联的下游服务通过监听这个队列进行处理，而不是直接受上游业务调用，对扩展性也很适配，下游服务添加新场景时对上游服务是无感知的，因为他们只需要对接消息队列，并不需要直接对上游业务发起回应调用

从设计模式的角度而言，这就像**生产者-消费者**模式，消息队列储存生产者业务生产出的消息，与其相关的消费者业务对队列中的消息执行消费

### 消息广播

消息广播可以让消费者组里所有的消费者对某个消息都做一次消费

消息广播的常用场景就是处理热点数据，比如说突发的明星塌方，成为一条“热点数据”，肯定需要通知所有服务防范热点数据的洪流。这种场景就非常适合使用消息广播，侦测到热点数据时发送一个消息到特定的消息队列里，让所有有可能接收到热点请求的应用服务接入这个队列，监听到后就可以及时执行热点逻辑

### 延迟业务

有部分任务是需要延迟的，它门会在未来的某个时间被执行，比如经典电商场景里的:

- 自动确认收货: 顾客签收商品后迟迟不确认收货，到达一定时间阈值后系统会自动确认

- 自动取消未支付订单: 下单后迟迟没有完成支付，30分钟后自动取消该订单

这些延迟业务都以通过延迟消息来实现，当然这种延迟的消息有可能会积压很多，还会需要消息分区等功能降低消息积压量

### 削峰填谷

- 削峰：削减峰值流量，当某个业务峰值流量超过系统吞吐量上限，而这类业务又是核心业务，不能简单粗暴地使用限流、降级、熔断等方式直接杀掉请求，可以使用消息队列收纳这些请求，让下游消费者业务根据自身的吞吐量从队列中获取这些消息进行消费

- 填谷: 峰值流量降低后，前面削峰阶段积压在消息队列里的请求就可以被下游消费者慢慢消化

削峰填谷就是一种平滑利用资源的手段，适用于实时性要求不高但并发量较高的业务，比如新店家入驻电商平台，需要将他们准备好的商品元数据一次性注册到商品中心、商品发布主图副图、营销优惠活动页面、详情页等等，这些请求其实实时性并不高，但是由于商品元数据极多，很容易达成流量洪峰冲击，使用消息队列就可以进行削峰填谷
